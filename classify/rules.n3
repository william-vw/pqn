@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .

{ ?pt dfg:inferredDiscoveredDecision ?norm_d } 
<= {   
    ?pt a dfg:DecisionPoint ; dfg:normative true ; dfg:discovered true .

    # collect decisions in discovered model
    (?disc_d {
        ?disc_l dfg:from ?pt ; dfg:to ?disc_d ; dfg:source dfg:discovered .

    } ?disc_ds) log:collectAllIn _:t .
    # "inf - disc_ds" log:trace ?disc_ds .

    # for each "missing" decision, i.e., in normative but not discovered model
    ?norm_l dfg:from ?pt ; dfg:to ?norm_d ; dfg:source dfg:normative .
    ?norm_d list:notIn ?disc_ds .
    # "inf - norm_d" log:trace ?norm_d .

    # missing decision's choice branch includes a discovered decision
    ( ?disc_ds ?norm_d ) dfg:inChoiceBranch ?determ .

    # no other incoming edges for discovered decision in normative model
    ( ?determ dfg:normative ) dfg:priors ?priors .
    # "inf - priors" log:trace ( ?priors "=>" ?determ ) .
    ?priors list:length 1 .
} .

{ ( ?options ?cur ) dfg:inChoiceBranch ?cur }
<= {
    ?cur list:in ?options .
    # "choice - found" log:trace ?cur .
    true log:callWithCut true .
} .

{ ( ?options ?cur ) dfg:inChoiceBranch ?found }
<= {
    # "choice - searching" log:trace ?cur .
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source dfg:normative .
    ( ?options ?next ) dfg:inChoiceBranch ?found .
} .


# helpers

{ ?a dfg:link ?l }
<= { ?l dfg:from ?a } .

{ ?a dfg:link ?l }
<= { ?l dfg:to ?a } .

# { ?a a dfg:Activity } <= { ?l dfg:from ?a } .
# { ?a a dfg:Activity } <= { ?l dfg:to ?a } .

{ ?a a dfg:DecisionPoint . } 
<= {
    ?l1 dfg:from ?a .
    ?l2 dfg:from ?a .
    ?l1 log:notEqualTo ?l2 .
} .

{ ?a dfg:normative true }
<= { ?a dfg:link ?l . ?l dfg:source dfg:normative } .

{ ?a dfg:discovered true }
<= { ?a dfg:link ?l . ?l dfg:source dfg:discovered } .

{ ( ?a ?src ) dfg:priors ?priors }
<= { 
    (?prior
        {
            ?l dfg:to ?a ; dfg:from ?prior ; dfg:source ?src
        }
    ?priors) log:collectAllIn _:t .
} .

{ ?m list:notIn ?lst } 
<= { (1 { ?m list:in ?lst } ()) log:collectAllIn _:t } .