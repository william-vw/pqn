@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .


# - infer missing events after a known event up until next decision point OR end
# (relies on stronger assumptions; likely not a good idea)
# (data1.n3)
{ ( ?from ?to ) dfg:inferredEventFromKnownEvent ?known_e }
<= {
    ?known_e dfg:inNormative true ; dfg:inDiscovered true .
    ( ?known_e () ) dfg:collectBranchLinks ?links .
    ( ?from ?to ) list:in ?links .
    _:t log:notIncludes { ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:discovered }
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?links }
<= {
    ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:normative .
    ( ?to dfg:normative ) dfg:decisionPoint true .
    ( ?cur (( ?from ?to )) ) list:append ?links .
    # "collect1" log:trace ( ?to ?links ).
    true log:callWithCut true .
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?cur }
<= {
    ?l dfg:from ?from ; dfg:to dfg:nil ; dfg:source dfg:normative .
    # "collect2" log:trace ( ?to ?cur ) .
    true log:callWithCut true .
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?links }
<= {
    ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:normative .
    ( ?cur (( ?from ?to )) ) list:append ?cur2 .
    # "collect3" log:trace ( ?to ?cur2 ) .
    ( ?to ?cur2 ) dfg:collectBranchLinks ?links .
} .



# - infer decisions based on their downstream events
# (data2.n3, data3.n3)
{ ( ?pt ?miss_dec ) dfg:inferredDecisionFromFollowingEvent ?disc_evt } 
<= {
    ( ?pt dfg:normative ) dfg:decisionPoint true .
    # "inf - pt" log:trace ?pt .

    # for each "missing" decision, i.e., in normative but not discovered model
    ?l dfg:from ?pt ; dfg:to ?miss_dec ; dfg:source dfg:normative .
    # if we leave this out, the next heuristic is a special case of this one
    # ?miss_dec dfg:inDiscovered false .
    # "inf - miss_dec" log:trace ?miss_dec .

    # missing decision's choice branch in normative model includes a discovered event
    ( ?pt ?miss_dec dfg:normative dfg:discovered ) dfg:inChoiceBranch ?disc_evt .
    # "inf - disc_evt" log:trace ?disc_evt .

    ( ?pt ?disc_evt ) dfg:consistentLink true .

    ( ?pt ?miss_dec ?disc_evt ) dfg:determinant true .
} .

{ ( ?start ?cur ?src ?in ) dfg:inChoiceBranch ?cur }
<= {
    ?cur log:notEqualTo dfg:nil ; dfg:foundIn ?in .
    # "choice - found" log:trace ?cur .
    true log:callWithCut true .
} .

{ ( ?start ?cur ?src ?in ) dfg:inChoiceBranch ?found }
<= {
    # ?cur dfg:notFoundIn ?in .
    # "choice - searching" log:trace ?cur .
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ?next log:notEqualTo ?start . # avoid loops
    ( ?start ?next ?src ?in ) dfg:inChoiceBranch ?found .
} .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<=
{ (1 { ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered } ()) log:collectAllIn _:t } .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<= {
    ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered .
    ( ?pt ( ?disc_prior ) dfg:normative ) dfg:inSomeBranch true .
} .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<= {
    ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered .
    ( ?disc_prior ( ?pt ) dfg:normative ) dfg:inSomeBranch true .
} .



# # - infer decision points based on decisions
# # (data3.n3)
# { ?pt dfg:inferredDecisionPointFromDecision ?d } 
# <= {
#     ( ?pt dfg:normative ) dfg:decisionPoint true .
#     ?pt dfg:inDiscovered false .

#     ?l dfg:from ?pt ; dfg:to ?d ; dfg:source dfg:normative .
#     ?d dfg:inDiscovered true .
#     ( ?pt ?d ) dfg:determinant true .
# } .


# helpers

{ ?m list:notIn ?lst } 
<= { (1 { ?m list:in ?lst } ()) log:collectAllIn _:t } .

{ ?e dfg:link ?l }
<= { ?l dfg:from ?e } .

{ ?e dfg:link ?l }
<= { ?l dfg:to ?e } .

# { ?e a dfg:Activity } <= { ?l dfg:from ?e } .
# { ?e a dfg:Activity } <= { ?l dfg:to ?e } .

{ ( ?pt ?src ) dfg:decisionPoint true } 
<= {
    ?l1 dfg:from ?pt ; dfg:to ?to1 ; dfg:source ?src .
    ?l2 dfg:from ?pt ; dfg:to ?to2 ; dfg:source ?src .
    ?l1 log:notEqualTo ?l2 .
    ?to1 log:notEqualTo ?to2 .
} .

{ ?e dfg:inNormative true }
<= { ?e dfg:foundIn dfg:normative } .

{ ?e dfg:inDiscovered true }
<= { ?e dfg:foundIn dfg:discovered } .

{ ?e dfg:foundIn ?src }
<= { ?e dfg:link ?l . ?l dfg:source ?src } .

{ ?e dfg:inNormative false }
<= { ?e dfg:notFoundIn dfg:normative }.

{ ?e dfg:inDiscovered false }
<= { ?e dfg:notFoundIn dfg:discovered }.

{ ?e dfg:notFoundIn ?src }
<= { 
    (1 { ?e dfg:link ?l . ?l dfg:source ?src } ()) log:collectAllIn _:t .
    # messes up log:trace's
    # _:t log:notIncludes { ?e dfg:link ?l . ?l dfg:source ?src } 
} .

{ ( ?pt ?miss_dec ?disc_evt ) dfg:determinant true }
<= {
    "determinant (0)" log:trace ( ?pt ?miss_dec ?disc_evt ) .

    ( ?pt ?disc_evt ) dfg:cutoffs ?cutoffs .
    "determinant (cutoffs)" log:trace ?cutoffs .

    ( ?disc_evt ( ?miss_dec ) ?cutoffs dfg:normative ) dfg:determinantPriors true .
} .

# cutoff is prior event in discovered model
# (cutoff states that part in between cutoff & event happened)
{ ( ?pt ?disc_evt ) dfg:cutoffs ?cutoffs }
<= {
    (?cutoff
        { 
            ?l dfg:from ?cutoff ; dfg:to ?disc_evt ; dfg:source dfg:discovered .
            ( ?cutoff ( ?pt ) dfg:normative ) dfg:inSomeBranch true .
            "cutoff" log:trace ( ?cutoff ?pt ) .
        } 
    ?cutoffs ) log:collectAllIn _:t .
}  .

{ ( ?cur ?oneOf ?src ) dfg:inSomeBranch true }
<= { 
    ?cur list:in ?oneOf .
    true log:callWithCut true .
} .

{ ( ?cur ?oneOf ?src ) dfg:inSomeBranch true }
<= {
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ( ?next ?oneOf ?src ) dfg:inSomeBranch true .
} .

# event is determinant if only 1 way from missing decision to event

{ ( ?subject ?subject ?cutoffs ) dfg:determinantPriors true }
<= { 
    # good branch: starts at missing decision
    "determinantPriors - good branch (1)" log:trace ?subject .
    true log:callWithCut true .
} .

{ ( ?cur ?subject ?cutoffs ) dfg:determinantPriors true }
<= { 
    "determinantPriors (0)" log:trace ( ?cur ?subject ?cutoffs ) .
    # bad branch: starts at cutoff, so not ruled out by discovered model
    ?cur list:notIn ?cutoffs .

    # bad branch: cutoff is in transitive closure but not after decision point
    # otherwise, branch would be ruled out by discovered model (good branch)
    (
        { ( ?cur ?cutoffs ) dfg:inSomeBranch true }
        { ( ?cur dfg:normative ) dfg:decisionPoint true }
    ) log:forAllIn _:t .

    # all prior branches must adhere to conditions
    # (so, also false if there are no more branches)
    ?x dfg:from ?y ; dfg:to ?cur ; dfg:source dfg:normative . # (at least one)
    ( 
        { ?l dfg:from ?prior ; dfg:to ?cur ; dfg:source dfg:normative }
        { 
            ( ?prior ?subject ?cutoffs ) dfg:determinantPriors true 
        }
    ) log:forAllIn _:t .
 } .