@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .


# - infer missing events after a known event up until next decision point OR end
# (relies on stronger assumptions; likely not a good idea)
# (data1.n3)
{ ( ?from ?to ) dfg:inferredEventFromKnownEvent ?known_e }
<= {
    ?known_e dfg:inNormative true ; dfg:inDiscovered true .
    ( ?known_e () ) dfg:collectBranchLinks ?links .
    ( ?from ?to ) list:in ?links .
    _:t log:notIncludes { ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:discovered }
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?links }
<= {
    ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:normative .
    ( ?to dfg:normative ) dfg:decisionPoint true .
    ( ?cur (( ?from ?to )) ) list:append ?links .
    # "collect1" log:trace ( ?to ?links ).
    true log:callWithCut true .
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?cur }
<= {
    ?l dfg:from ?from ; dfg:to dfg:nil ; dfg:source dfg:normative .
    # "collect2" log:trace ( ?to ?cur ) .
    true log:callWithCut true .
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?links }
<= {
    ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:normative .
    ( ?cur (( ?from ?to )) ) list:append ?cur2 .
    # "collect3" log:trace ( ?to ?cur2 ) .
    ( ?to ?cur2 ) dfg:collectBranchLinks ?links .
} .



# - infer decisions based on their downstream events
# (data2.n3, data3.n3)
{ ( ?pt ?miss_dec ) dfg:inferredDecisionFromFollowingEvent ?disc_evt } 
<= {
    ( ?pt dfg:normative ) dfg:decisionPoint true .
    # "inf - pt" log:trace ?pt .

    # for each "missing" decision, i.e., in normative but not discovered model
    ?l dfg:from ?pt ; dfg:to ?miss_dec ; dfg:source dfg:normative .
    # if we leave this out, the next heuristic is a special case of this one
    # ?miss_dec dfg:inDiscovered false .
    # "inf - miss_dec" log:trace ?miss_dec .

    # missing decision's choice branch in normative model includes a discovered event
    ( ?pt ?miss_dec dfg:normative dfg:discovered ) dfg:inChoiceBranch ?disc_evt .
    # "inf - disc_evt" log:trace ?disc_evt .

    ( ?pt ?disc_evt ) dfg:consistentLink true .

    ( ?miss_dec ?disc_evt dfg:normative ) dfg:determinant true .
} .

{ ( ?start ?cur ?src ?in ) dfg:inChoiceBranch ?cur }
<= {
    ?cur log:notEqualTo dfg:nil ; dfg:foundIn ?in .
    # "choice - found" log:trace ?cur .
    true log:callWithCut true .
} .

{ ( ?start ?cur ?src ?in ) dfg:inChoiceBranch ?found }
<= {
    # ?cur dfg:notFoundIn ?in .
    # "choice - searching" log:trace ?cur .
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ?next log:notEqualTo ?start . # avoid loops
    ( ?start ?next ?src ?in ) dfg:inChoiceBranch ?found .
} .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<=
{ (1 { ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered } ()) log:collectAllIn _:t } .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<= {
    ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered .
    ( ?pt ?disc_prior dfg:normative ) dfg:inBranch true .
} .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<= {
    ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered .
    ( ?disc_prior ?pt dfg:normative ) dfg:inBranch true .
} .



# - infer decision points based on decisions
# (data3.n3)
{ ?pt dfg:inferredDecisionPointFromDecision ?d } 
<= {
    ( ?pt dfg:normative ) dfg:decisionPoint true .
    ?pt dfg:inDiscovered false .

    ?l dfg:from ?pt ; dfg:to ?d ; dfg:source dfg:normative .
    ?d dfg:inDiscovered true .
    ( ?pt ?d dfg:normative ) dfg:determinant true .
} .


# helpers

{ ?m list:notIn ?lst } 
<= { (1 { ?m list:in ?lst } ()) log:collectAllIn _:t } .

{ ?e dfg:link ?l }
<= { ?l dfg:from ?e } .

{ ?e dfg:link ?l }
<= { ?l dfg:to ?e } .

# { ?e a dfg:Activity } <= { ?l dfg:from ?e } .
# { ?e a dfg:Activity } <= { ?l dfg:to ?e } .

{ ( ?pt ?src ) dfg:decisionPoint true } 
<= {
    ?l1 dfg:from ?pt ; dfg:to ?to1 ; dfg:source ?src .
    ?l2 dfg:from ?pt ; dfg:to ?to2 ; dfg:source ?src .
    ?l1 log:notEqualTo ?l2 .
    ?to1 log:notEqualTo ?to2 .
} .

{ ?e dfg:inNormative true }
<= { ?e dfg:foundIn dfg:normative } .

{ ?e dfg:inDiscovered true }
<= { ?e dfg:foundIn dfg:discovered } .

{ ?e dfg:foundIn ?src }
<= { ?e dfg:link ?l . ?l dfg:source ?src } .

{ ?e dfg:inNormative false }
<= { ?e dfg:notFoundIn dfg:normative }.

{ ?e dfg:inDiscovered false }
<= { ?e dfg:notFoundIn dfg:discovered }.

{ ?e dfg:notFoundIn ?src }
<= { 
    (1 { ?e dfg:link ?l . ?l dfg:source ?src } ()) log:collectAllIn _:t .
    # messes up log:trace's
    # _:t log:notIncludes { ?e dfg:link ?l . ?l dfg:source ?src } 
} .

{ ( ?pt ?miss_dec ?disc_evt ) dfg:determinant true }
<= {
    (?disc_prior 
    { 
        ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered .
        ( ?disc_prior ?pt dfg:normative ) dfg:inBranch true .
    } 
    ?disc_priors) log:collectAllIn _:t .

    ( ( ?miss_dec ) ?disc_priors ?disc_evt dfg:normative ) dfg:forAllPriorBranches true .
} .


{ ( ?cur ?cur ?src ) dfg:inBranch true }
<= { } .

{ ( ?cur ?needle ?src ) dfg:inBranch true }
<= {
    ?cur log:notEqualTo ?needle .
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ( ?next ?needle ?src ) dfg:inBranch true .
} .


{ ( ?trueAt ?falseAt ?cur ?src ) dfg:forAllPriorBranches true }
<= {
    ?l dfg:from ?prior ; dfg:to ?cur ; dfg:source ?src .
    ?cur list:notIn ?falseAt . # stop if in falseAt - branch (so entire search) is nok

    ( ?trueAt ?falseAt ?prior ?src ) dfg:forAllPriorBranches true
 } .

# found trueAt in branch - ok
{ ( ?trueAt ?falseAt ?cur ?src ) dfg:forAllPriorBranches true }
<= { 
    ?cur list:in ?trueAt .
    true log:callWithCut true .
} .

# branch is done - ok
{ ( ?trueAt ?falseAt ?cur ?src ) dfg:forAllPriorBranches true }
<= { (1 { ?l dfg:from ?prior ; dfg:to ?cur ; dfg:source ?src } ()) log:collectAllIn _:t } .
