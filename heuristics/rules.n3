@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .


# - infer missing events after a known event up until next decision point OR end
# (relies on stronger assumptions; likely not a good idea)
# (data1.n3)
{ ( ?from ?to ) dfg:inferredEventFromKnownEvent ?known_e }
<= {
    ?known_e dfg:inNormative true ; dfg:inDiscovered true .
    ( ?known_e () ) dfg:collectBranchLinks ?links .
    ( ?from ?to ) list:in ?links .
    _:t log:notIncludes { ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:discovered }
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?links }
<= {
    ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:normative .
    ( ?to dfg:normative ) dfg:decisionPoint true .
    ( ?cur (( ?from ?to )) ) list:append ?links .
    # "collect1" log:trace ( ?to ?links ).
    true log:callWithCut true .
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?cur }
<= {
    ?l dfg:from ?from ; dfg:to dfg:nil ; dfg:source dfg:normative .
    # "collect2" log:trace ( ?to ?cur ) .
    true log:callWithCut true .
} .

{ ( ?from ?cur ) dfg:collectBranchLinks ?links }
<= {
    ?l dfg:from ?from ; dfg:to ?to ; dfg:source dfg:normative .
    ( ?cur (( ?from ?to )) ) list:append ?cur2 .
    # "collect3" log:trace ( ?to ?cur2 ) .
    ( ?to ?cur2 ) dfg:collectBranchLinks ?links .
} .



# - infer decisions based on their downstream events
# (data2.n3, data3.n3)
{ ( ?pt ?miss_dec ) dfg:inferredDecisionFromFollowingEvent ?disc_evt } 
<= {
    ( ?pt dfg:normative ) dfg:decisionPoint true .
    # "inf - pt" log:trace ?pt .

    # for each "missing" decision, i.e., in normative but not discovered model
    ?l dfg:from ?pt ; dfg:to ?miss_dec ; dfg:source dfg:normative .
    # if we leave this out, the next heuristic is a special case of this one
    # ?miss_dec dfg:inDiscovered false .
    # "inf - miss_dec" log:trace ?miss_dec .

    # missing decision's choice branch in normative model includes a discovered event
    ( ?miss_dec dfg:normative dfg:discovered ) dfg:inChoiceBranch ?disc_evt .
    # "inf - disc_evt" log:trace ?disc_evt .

    # discovered decision is determinant in normative model
    # (note: could integrate this into dfg:inChoiceBranch)
    ( ?miss_dec ?disc_evt dfg:normative ) dfg:determinant true .
} .

{ ( ?cur ?src ?in ) dfg:inChoiceBranch ?cur }
<= {
    ?cur dfg:foundIn ?in .
    # "choice - found" log:trace ?cur .
} .

{ ( ?cur ?src ?in ) dfg:inChoiceBranch ?found }
<= {
    ?cur dfg:notFoundIn ?in .
    # "choice - searching" log:trace ?cur .
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ( ?next ?src ?in ) dfg:inChoiceBranch ?found .
} .



# - infer decision points based on decisions
# (data3.n3)
{ ?pt dfg:inferredDecisionPointFromDecision ?d } 
<= {
    ( ?pt dfg:normative ) dfg:decisionPoint true .
    ?pt dfg:inDiscovered false .

    ?l dfg:from ?pt ; dfg:to ?d ; dfg:source dfg:normative .
    ?d dfg:inDiscovered true .
    ( ?pt ?d dfg:normative ) dfg:determinant true .
} .


# helpers

{ ?m list:notIn ?lst } 
<= { (1 { ?m list:in ?lst } ()) log:collectAllIn _:t } .

{ ?e dfg:link ?l }
<= { ?l dfg:from ?e } .

{ ?e dfg:link ?l }
<= { ?l dfg:to ?e } .

# { ?e a dfg:Activity } <= { ?l dfg:from ?e } .
# { ?e a dfg:Activity } <= { ?l dfg:to ?e } .

{ ( ?pt ?src ) dfg:decisionPoint true } 
<= {
    ?l1 dfg:from ?pt ; dfg:to ?to1 ; dfg:source ?src .
    ?l2 dfg:from ?pt ; dfg:to ?to2 ; dfg:source ?src .
    ?l1 log:notEqualTo ?l2 .
    ?to1 log:notEqualTo ?to2 .
} .

{ ?e dfg:inNormative true }
<= { ?e dfg:foundIn dfg:normative } .

{ ?e dfg:inDiscovered true }
<= { ?e dfg:foundIn dfg:discovered } .

{ ?e dfg:foundIn ?src }
<= { ?e dfg:link ?l . ?l dfg:source ?src } .

{ ?e dfg:inNormative false }
<= { ?e dfg:notFoundIn dfg:normative }.

{ ?e dfg:inDiscovered false }
<= { ?e dfg:notFoundIn dfg:discovered }.

{ ?e dfg:notFoundIn ?src }
<= { 
    (1
        { ?e dfg:link ?l . ?l dfg:source ?src }
    ()) log:collectAllIn _:t .
    # messes up log:trace's
    # _:t log:notIncludes { ?e dfg:link ?l . ?l dfg:source ?src } 
} .

{ ( ?e ?src ) dfg:priors ?priors }
<= { 
    (?prior { ?l dfg:to ?e ; dfg:from ?prior ; dfg:source ?src } ?priors) 
        log:collectAllIn _:t .
} .

{ ( ?from ?from ?src ) dfg:determinant true }
<= { 
    # "determ" log:trace ?from .
    true log:callWithCut true .
} .

{ ( ?from ?cur ?src ) dfg:determinant true }
<= { 
    ( ?cur ?src ) dfg:priors ?priors .
    ?priors list:length 1 .

    ?prior list:in ?priors .
    ( ?from ?prior ?src ) dfg:determinant true
 } .