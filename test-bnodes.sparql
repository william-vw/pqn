PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX tr: <http://example.org/trace#>
PREFIX : <http://example.org#>

# (log-bnodes.rdf)

# there exists a given activity

# activityOccurs
# SELECT ?t
# WHERE { 
#     [ tr:from :a5 ] tr:in ?t .
# }

# there does not exist a given activity

# activityDoesNotOccur
# SELECT DISTINCT ?t
# WHERE { 
#     # TODO annotate activities with type tr:Trace
#     ?a tr:in ?t
#     FILTER NOT EXISTS  { ?x tr:from :a2 ; tr:in ?t . }
# }

# two activities don't co-occur

# SELECT DISTINCT ?t
# WHERE { 
#     ?a tr:in ?t
#     FILTER NOT EXISTS  { 
#         [ tr:from :a4 ] tr:in ?t . 
#         [ tr:from :a5 ] tr:in ?t . 
#     }
# }

# either two activities both occur or neither occur

# SELECT DISTINCT ?t
# WHERE { 
#     {
#         [ tr:from :a3 ] tr:in ?t .
#         [ tr:from :a5 ] tr:in ?t .
#     }
#     UNION
#     {
#         {
#             ?a tr:in ?t .
#         }
#         # subtract all traces where :a3 *or* :a5 occur
#         # (cases where :a3 *and* :a5 occur are captured in first union operand)
#         MINUS
#         { 
#             [ tr:from :a3 ] tr:in ?t
#         }
#         MINUS
#         {
#             [ tr:from :a5 ] tr:in ?t . 
#         }
#     }
# }

# there exists a certain sequence

# sequenceOccurs
# SELECT ?t
# WHERE { 
#     [ tr:from :a1 ; tr:to :a2 ] tr:in ?t .
#     [ tr:from :a2 ; tr:to :a3 ] tr:in ?t .
# }

# (get percentage of matching traces)

# SELECT ?match_num ?total_num ?perc
# WHERE { 
#     {
#         SELECT (COUNT(?t0) as ?match_num)
#         WHERE {
#             [ tr:from :a1 ; tr:to :a2 ] tr:in ?t0 .
#             [ tr:from :a2 ; tr:to :a3 ] tr:in ?t0 .
#         }
#     }
#     {
#         SELECT (COUNT(DISTINCT ?t) as ?total_num)
#         WHERE {
#             ?x tr:in ?t .
#         }
#     }
#     BIND ( ( ?match_num / ?total_num ) AS ?perc )
# }

# there does not exist a certain sequence

# sequenceDoesNotOccur
# SELECT ?t
# WHERE { 
#     ?x tr:in ?t .
#     FILTER NOT EXISTS  { [ tr:from :a2 ; tr:to :a3 ] tr:in ?t . }
# }

# get start activities
# (could also have trace start with [ tr:from rdf:nil ; tr:to ?start ])

# SELECT ?start ?t
# WHERE {
#     [ tr:from ?start ; tr:to ?next ] tr:in ?t .
#     FILTER NOT EXISTS { [ tr:from ?prior ; tr:to ?start ] tr:in ?t . }
# }

# a given activity precedes another given activity
# cannot do this in regular SPARQL - see test_bnodes.n3

# SELECT DISTINCT ?t
# WHERE { 
#     ?t ^tr:in/tr:from :a1 .
#     # does not ensure that same trace ?t is still used
#     # does not ensure that :a1 is before :a4
#     ?t ^tr:in/tr:to/(^tr:from/tr:to)* :a4
# }

# (log-bnodes-exp.rdf)

# get pairs of actors working together

# actorPairsWithHandOver
# SELECT DISTINCT ?actor1 ?actor2
# WHERE {
#     [ tr:from [ tr:actor ?actor1 ] ; tr:to [ tr:actor ?actor2 ] ] tr:in ?t .
#     FILTER ( !sameTerm(?actor1, ?actor2)  )
# }

# get actors with counts of outgoing edges (possibly to same actor)

# handOverCountPerActor
# SELECT ?actor1 (COUNT(?t) as ?num_traces)
# WHERE {
#     [ tr:from [ tr:actor ?actor1 ] ; tr:to [ tr:actor ?actor2 ] ] tr:in ?t .
# }
# GROUP BY ?actor1
# ORDER BY DESC(?num_traces)

# get avg duration for given activity grouped by actor

# averageActivityDurationPerActor
# SELECT ?actor (AVG(?d) as ?avg_dur) (MAX(?d) as ?max_dur) (COUNT(?t) as ?num_traces)
# WHERE {
#     [ (tr:from|tr:to) [ tr:activity :a3 ; tr:actor ?actor ; tr:duration ?d ] ] tr:in ?t .
# }
# GROUP BY ?actor
# ORDER BY DESC(?avg_dur)

# get total duration of traces

# totalDurationPerTrace
# SELECT ?t (SUM(?d) as ?total_dur)
# WHERE {
#     [ tr:from [ tr:duration ?d ] ] tr:in ?t .
# }
# GROUP BY ?t
# ORDER BY DESC(?total_dur)

# get actors involved in traces that take longer than average
# good example for need of sin3

# this is likely quite inefficient (.. also in sin3)
# as per the spec, the inner query is first executed, and then joined with the outer one
# well, it doesn't work any way in jena

# SELECT DISTINCT ?t ?trace_dur ?avg_overall_dur
# {
#     [ tr:from ?x ] tr:in ?t .
#     {
#         SELECT ?t (SUM(?d) as ?trace_dur)
#         WHERE {
#             [ tr:from [ tr:duration ?d ] ] tr:in ?t .
#         }
#         GROUP BY ?t
#     }
    
#     {
#         SELECT (AVG(?trace_dur) as ?avg_overall_dur)
#         WHERE {
#             {
#                 SELECT ?at (SUM(?ad) as ?trace_dur)
#                 WHERE {
#                     [ tr:from [ tr:duration ?ad ] ] tr:in ?at .
#                 }
#                 GROUP BY ?at
#             }
#         }
#     }

#     # FILTER (?trace_dur >= ?avg_trace_dur)
# }

# two activities occur concurrently

SELECT DISTINCT ?t
WHERE { 
    [ tr:from [ tr:activity :a1 ; tr:ts ?ts1 ] ] tr:in ?t .
    [ tr:from [ tr:activity :a2 ; tr:ts ?ts2 ] ] tr:in ?t .
    FILTER ( ABS(?ts1 - ?ts2) < 60 ) # within 1 minute
}