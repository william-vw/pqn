@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .


# - infer decisions based on their downstream events

{ ( ?pt ?miss_dec ) dfg:inferredDecisionFromFollowingEvent ?disc_evt } 
<= {
    # normative DP
    ( ?pt dfg:normative ) dfg:decisionPoint true .
    # "inf - pt" log:trace ?pt .

    # for each "missing" decision, i.e., in normative but not discovered model
    ?l dfg:from ?pt ; dfg:to ?miss_dec ; dfg:source dfg:normative .
    # if we leave this out, the next heuristic is a special case of this one
    ?miss_dec dfg:inDiscovered false .
    "inf - miss_dec" log:trace (?pt ?miss_dec) .

    # missing decision's choice branch in normative model includes a discovered event
    ( ?miss_dec (dfg:inDiscovered true) dfg:normative ) dfg:withPredInBranch ?disc_evt .
    "inf - disc_evt" log:trace ?disc_evt .

    # missing decision is a proper determinant of DP
    # TODO expand generalize "evidence" here
    # e.g., if e is determinant of b, and x -> e, then also x -> b
    # separate inference to determine cutoffs
    # simply B->A rules - follow the transitive closure
    # ( ?miss_dec ?pt ) dfg:determinant true .

    # linked discovered event(s) are consistent with DP
    # TODO should we also do transitive closure here? ...
    ( ?pt ?disc_evt ) dfg:consistentLink true .

    # discovered event is a proper determinant of missing decision
    ( ?disc_evt ?miss_dec ) dfg:determinant true .
} .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<=
{ 
    (1 { ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered } ()) log:collectAllIn _:t .
    true log:callWithCut true .
    "consistentLink (1)" log:trace ?pt .    
} .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<= {
    ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered .
    ( ?pt ( ?disc_prior ) dfg:normative ) dfg:oneOfIsInBranch true .
    true log:callWithCut true .
    "consistentLink (2)" log:trace (?pt ?disc_prior) .
} .

{ ( ?pt ?disc_evt ) dfg:consistentLink true }
<= {
    ?l dfg:from ?disc_prior ; dfg:to ?disc_evt ; dfg:source dfg:discovered .
    ( ?disc_prior ( ?pt ) dfg:normative ) dfg:oneOfIsInBranch true .
    true log:callWithCut true .
    "consistentLink (3)" log:trace (?disc_prior ?pt) .
} .

{ ( ?determ ?subject ) dfg:determinant true }
<= {
    "determinant (0)" log:trace ( ?determ ?subject ) .

    ( ?determ ?subject ) dfg:cutoffs ?cutoffs .
    "determinant (cutoffs)" log:trace ?cutoffs .

    ( ?determ ?subject ?cutoffs ) dfg:determinantPriors true .
} .

# cutoff is prior event in discovered model
# (cutoff states that part in between cutoff & event happened)
{ ( ?determ ?subject ) dfg:cutoffs ?cutoffs }
<= {
    (?cutoff
        { 
            ?l dfg:from ?cutoff ; dfg:to ?determ ; dfg:source dfg:discovered .
            ( ?cutoff ( ?subject ) dfg:normative ) dfg:oneOfIsInBranch true .
        } 
    ?cutoffs ) log:collectAllIn _:t .
}  .

# event is determinant if only 1 way from missing decision to event

{ ( ?subject ?subject ?cutoffs ) dfg:determinantPriors true }
<= { 
    # good branch: starts at missing decision
    "determinantPriors - good branch (starts at subject)" log:trace ?subject .
    true log:callWithCut true .
} .

{ ( ?cur ?subject ?cutoffs ) dfg:determinantPriors true }
<= {
    ?cur list:notIn ?cutoffs .
    # good branch: includes a cutoff in its transitive closure
    # so, it's a decision point since it leads to extra prior link *and* cutoff
    # and, the cutoff had been chosen and not the extra prior link
    ( ?cur ?cutoffs dfg:normative ) dfg:oneOfIsInBranch true .
    "determinantPriors - good branch (ruled out by cutoff)" log:trace ( ?cur ?cutoffs ) .
    true log:callWithCut true .
} .

{ ( ?cur ?subject ?cutoffs ) dfg:determinantPriors true }
<= { 
    "determinantPriors (subject)" log:trace ( ?cur "in?" ?cutoffs ) .
    # bad branch: starts at cutoff, so not ruled out by discovered model
    ?cur list:notIn ?cutoffs .

    # all prior branches must adhere to conditions
    # (so, also false if there are no more branches)
    ?x dfg:from ?y ; dfg:to ?cur ; dfg:source dfg:normative . # (at least one)
    ( 
        {
            ?l dfg:from ?prior ; dfg:to ?cur ; dfg:source dfg:normative .
            "determinantPriors (link)" log:trace ( ?prior "=>" ?cur )
        }
        { 
            ( ?prior ?subject ?cutoffs ) dfg:determinantPriors true 
        }
    ) log:forAllIn _:t .
 } .


# helpers

{ ?m list:notIn ?lst } 
<= { (1 { ?m list:in ?lst } ()) log:collectAllIn _:t } .

{ ?e dfg:link ?l }
<= { ?l dfg:from ?e } .

{ ?e dfg:link ?l }
<= { ?l dfg:to ?e } .

# { ?e a dfg:Activity } <= { ?l dfg:from ?e } .
# { ?e a dfg:Activity } <= { ?l dfg:to ?e } .

{ ( ?pt ?src ) dfg:decisionPoint true } 
<= {
    ?l1 dfg:from ?pt ; dfg:to ?to1 ; dfg:source ?src .
    ?l2 dfg:from ?pt ; dfg:to ?to2 ; dfg:source ?src .
    ?l1 log:notEqualTo ?l2 .
    ?to1 log:notEqualTo ?to2 .
} .

{ ?e dfg:inNormative true }
<= { ?e dfg:foundIn dfg:normative } .

{ ?e dfg:inDiscovered true }
<= { ?e dfg:foundIn dfg:discovered } .

{ ?e dfg:foundIn ?src }
<= { ?e dfg:link ?l . ?l dfg:source ?src } .

{ ?e dfg:inNormative false }
<= { ?e dfg:notFoundIn dfg:normative }.

{ ?e dfg:inDiscovered false }
<= { ?e dfg:notFoundIn dfg:discovered }.

{ ?e dfg:notFoundIn ?src }
<= { 
    (1 { ?e dfg:link ?l . ?l dfg:source ?src } ()) log:collectAllIn _:t .
    # messes up log:trace's
    # _:t log:notIncludes { ?e dfg:link ?l . ?l dfg:source ?src } 
} .

{ ( ?cur ?oneOf ?src ) dfg:oneOfIsInBranch true }
<= { 
    ?cur list:in ?oneOf .
    true log:callWithCut true .
} .

{ ( ?cur ?oneOf ?src ) dfg:oneOfIsInBranch true }
<= {
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ( ?next ?oneOf ?src ) dfg:oneOfIsInBranch true .
} .

{ ( ?cur (?pred ?value) ?src ) dfg:withPredInBranch ?cur }
<= {
    ?cur ?pred ?value .
    true log:callWithCut true .
} .

{ ( ?cur (?pred ?value) ?src ) dfg:withPredInBranch ?found }
<= {
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ( ?next (?pred ?value) ?src ) dfg:withPredInBranch ?found .
} .