@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .

# @import utils.n3

# principles (graph-based!) - given discovered event e:
# (aside from "e", all below refers to normative model)

# 1/ causality - e _implies_ d if:
# 	reverse transitive closure of e = forward transitive closure of d
#   i.e., to arrive at e, had to have gone through d
# (special/simple case: exists normative link d -> e _and_ no other d' exists where d' <> d and d' -> e)

# special/simple case
{
    ?e dfg:inDiscovered true ; log:notEqualTo dfg:nil .
    ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .
    ?from dfg:validBranch true .

    (   # if another incoming link exists
        {
            ?l2 dfg:from ?from2 ; dfg:to ?e ; dfg:source dfg:normative .
            ?from2 log:notEqualTo ?from .   
        }
        # it must come from an invalid branch
        { ?from2 dfg:invalidBranch true }
    ) log:forAllIn _:t .

} => {
    [
        dfg:from ?from ; dfg:to ?e ; dfg:source dfg:discovered ;
        dfg:inferred [ dfg:reason "priorEvent" ; dfg:priorEvent ?e ]
    ]
} .

# complex case
{
    ?e dfg:inDiscovered true ; log:notEqualTo dfg:nil .

    # at least 2 valid incoming links
    (?l {
        ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .
        ?from dfg:validBranch true .
    } ?in) log:collectAllIn _:t .
    ?in!list:length math:notLessThan 2 .

    # ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .
    # ?l2 dfg:from ?from2 ; dfg:to ?e ; dfg:source dfg:normative .
    # ?from2 log:notEqualTo ?from .
    # ?from dfg:validBranch true .
    # ?from2 dfg:validBranch true .

    # "converge (0)" log:trace ?e .

    # get reverse transitive closures of all incoming links
    (?closure
        {
            ?l_n dfg:from ?from_n ; dfg:to ?e ; dfg:source dfg:normative .
            ( ?from_n dfg:normative () ) dfg:priorTransitiveClosure ?closure .
        }
    ?closures) log:collectAllIn ( ?ctx 5 ) .

    # "converge (1)" log:trace ( ?e ?closures ) .

    # if they have an element in common;
    # that element has the same forward transitive closure
    ?closures list:intersect ?shareds .
    ( ?shareds 0 ) list:memberAt ?shared .

    # "converge" log:trace ( ?e ?shared ) .

    # also, make sure these are not yet connected
    # (avoid redundant links)
    # ( ?shared ?e dfg:discovered ) dfg:reachable false .

} => {
    [ 
        a dfg:IndirectLink ;
        dfg:from ?shared ; dfg:to ?e ; dfg:source dfg:discovered ;
        dfg:inferred [ dfg:reason "convergingPriorTransitiveClosure" ]
    ]
} .


# 2/ mutually exclusive choices
# if e is a choice of a DP, this _rules out_ other choices & their unique transitive closure 
# (i.e., not incl. nodes also accessible via other nodes)

# rule out other choices given a discovered choice
{   ?e dfg:inDiscovered true .

    # event's associated DP
    ?l dfg:from ?dp ; dfg:to ?e ; dfg:source dfg:normative .
    ( ?dp dfg:normative ) dfg:decisionPoint true .

    # DP's other choices
    ?l2 dfg:from ?dp ; dfg:to ?e2 ; dfg:source dfg:normative .
    ?e2 log:notEqualTo ?e ; log:notEqualTo dfg:nil .

    # (avoid multiple invalidations)
    ?e2 dfg:validBranch true .

    # # mutex - we chose a, so we didn't chose b
    # # but, contradicted by:
    # # if b can still occur after a (a is anc of b), 
    # ( ?e2 ?e dfg:normative ) dfg:ancestor false .
    # # or if a can still occur after b (b is anc of a)
    # ( ?e ?e2 dfg:normative ) dfg:ancestor false .

} => {
    ?e2 dfg:invalidated [
        dfg:reason "otherChoiceDiscovered" ;
        dfg:otherChoice ?e
    ]
} .

# propagate invalid branch
{
    ?e dfg:invalidBranch true .

    ?l dfg:from ?e ; dfg:to ?to ; dfg:source dfg:normative .
    ?to log:notEqualTo dfg:nil .

    # (avoid multiple invalidations, loops)
    ?to dfg:validBranch true .

    (   # for any incoming link
        { ?lp dfg:from ?p ; dfg:to ?to ; dfg:source dfg:normative }
        # it must come from an invalid branch
        { ?p dfg:invalidBranch true }
    ) log:forAllIn _:t .

} => {
    ?to dfg:invalidated [
        dfg:reason "invalidatedTransitiveClosure" ;
        dfg:priorInvalid ?e
    ]
} .


# # 0/ find single path between discovered events
# {
#     ?l dfg:source dfg:discovered ; dfg:from ?from ; dfg:to ?to .
#     ?to log:notEqualTo dfg:nil .

#     (?path
#         { ( ?from ?to dfg:normative () ) dfg:pathBetween ?path }
#     ?paths) log:collectAllIn _:t .

#     # "paths" log:trace ( ?from ?to ) .
#     # "paths" log:trace ?paths .
    
#     ?paths list:length 1 .
#     # get single path
#     ?path list:in ?paths .

#     # get each link in path
#     ( ?from_i ?to_i ) list:in ?path .
#     # (not yet inferred)
#     ( 1 { ?x dfg:from ?from_i ; dfg:to ?to_i ; dfg:source dfg:discovered } () ) log:collectAllIn _:t .

# } => {
#     # infer the link
#     [
#         dfg:from ?from_i ; dfg:to ?to_i ; dfg:source dfg:discovered ;
#         dfg:inferred [ dfg:reason "onDiscoveredPath" ; dfg:path ( ?from ?to ) ]
#     ]
# } .

# # x/ invalidate everything not reachable from a discovered event
# {
#     ?e dfg:link ?l . ?l dfg:source dfg:normative .
#     ?e dfg:canReachDiscovered false .

# } => {
#     ?e dfg:invalidated [
#         dfg:reason "cannotReachDiscovered" 
#     ]
# } .