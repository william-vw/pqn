@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .

# principles (graph-based!) - given discovered event e:
# (aside from "e", all below refers to normative model)

# 1/ e _implies_ d if:
# 	reverse transitive closure of e = forward transitive closure of d
# 	i.e., all prior branches of e arrive at d
# (special case: exists normative link d -> e _and_ no other d' exists where d' <> d and d' -> e)

{
    ?e dfg:inDiscovered true .
    ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .

    (
        {
            ?l2 dfg:from ?from2 ; dfg:to ?e ; dfg:source dfg:normative .
            ?from2 log:notEqualTo ?from .   
        }
        { ?from2 dfg:ruledOutBranch true }
    ) log:forAllIn _:t .

} => {
    [
        dfg:from ?from ;
        dfg:to ?e ;
        dfg:source dfg:discovered ;
        dfg:inferred [ 
            dfg:heuristic "inferredFromPriorEvent" ;
            dfg:priorEvent ?e
        ]
    ]
} .

{
    ?e dfg:inDiscovered true .

    ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .
    ?l2 dfg:from ?from2 ; dfg:to ?e ; dfg:source dfg:normative .
    ?from2 log:notEqualTo ?from .

    (?closure
        {
            ?l_n dfg:from ?from_n ; dfg:to ?e ; dfg:source dfg:normative .
            ( ?from_n dfg:normative () ) dfg:priorTransitiveClosure ?closure .
        }
    ?closures) log:collectAllIn _:t .

    ?closures list:intersect ?shareds .
    ( ?shareds 0 ) list:memberAt ?shared .

} => {
    [
        dfg:from ?shared ;
        dfg:to ?e ;
        dfg:source dfg:discovered ;
        dfg:inferred [ 
            dfg:heuristic "inferredFromPriorTransitiveClosure"
        ]
    ]
} .

# 2/ if e is a choice of a DP, this _rules out other choices & their _unique_ transitive closure 
# (not incl. nodes also reachable via other nodes)

{
    ?e dfg:inDiscovered true .

    ?l dfg:from ?dp ; dfg:to ?e ; dfg:source dfg:normative .
    ( ?dp dfg:normative ) dfg:decisionPoint true .

    ?l2 dfg:from ?dp ; dfg:to ?e2 ; dfg:source dfg:normative .
    ?e2 log:notEqualTo ?e . # ; dfg:inDiscovered false . (assume mutex choices)

} => {
    ?e2 dfg:ruledOutBranch true .
} .

{
    ?e dfg:ruledOutBranch true .

    ?l dfg:from ?e ; dfg:to ?to ; dfg:source dfg:normative .
    (
        { ?lp dfg:from ?p ; dfg:to ?to ; dfg:source dfg:normative }
        { ?p dfg:ruledOutBranch true }
    ) log:forAllIn _:t .

} => {
    ?to dfg:ruledOutBranch true 
} .


# helpers

{ ?m list:notIn ?lst } 
<= { (1 { ?m list:in ?lst } ()) log:collectAllIn _:t } .

{ ?lists list:intersect ?intersect }
<= {
    ( ?lists 0 ) list:memberAt ?list_0 .
    (?element
        {
            ?element list:in ?list_0.
            (
                { ?list_i list:in ?lists }
                { ?element list:in ?list_i }
            ) log:forAllIn _:t . 
        }
    ?intersect ) log:collectAllIn _:t .
} .

{ ?e dfg:link ?l }
<= { ?l dfg:from ?e } .

{ ?e dfg:link ?l }
<= { ?l dfg:to ?e } .

# { ?e a dfg:Activity } <= { ?l dfg:from ?e } .
# { ?e a dfg:Activity } <= { ?l dfg:to ?e } .

{ ( ?pt ?src ) dfg:decisionPoint true } 
<= {
    ?l1 dfg:from ?pt ; dfg:to ?to1 ; dfg:source ?src .
    ?l2 dfg:from ?pt ; dfg:to ?to2 ; dfg:source ?src .
    ?l1 log:notEqualTo ?l2 .
    ?to1 log:notEqualTo ?to2 .
} .

{ ( ?pt ?src ) dfg:decisionPoint false } 
<= {
    ( 1 { ( ?pt ?src ) dfg:decisionPoint true } () ) log:collectAllIn _:t .
} .

{ ?e dfg:inNormative true }
<= { ?e dfg:foundIn dfg:normative } .

{ ?e dfg:inDiscovered true }
<= { ?e dfg:foundIn dfg:discovered } .

{ ?e dfg:foundIn ?src }
<= { ?e dfg:link ?l . ?l dfg:source ?src } .

{ ?e dfg:inNormative false }
<= { ?e dfg:notFoundIn dfg:normative }.

{ ?e dfg:inDiscovered false }
<= { ?e dfg:notFoundIn dfg:discovered }.

{ ?e dfg:notFoundIn ?src }
<= { 
    (1 { ?e dfg:link ?l . ?l dfg:source ?src } ()) log:collectAllIn _:t .
    # messes up log:trace's
    # _:t log:notIncludes { ?e dfg:link ?l . ?l dfg:source ?src } 
} .

{ ( ?cur ?oneOf ?src ) dfg:oneOfIsInBranch true }
<= { 
    ?cur list:in ?oneOf .
    true log:callWithCut true .
} .

{ ( ?cur ?oneOf ?src ) dfg:oneOfIsInBranch true }
<= {
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ( ?next ?oneOf ?src ) dfg:oneOfIsInBranch true .
} .

{ ( ?cur (?pred ?value) ?src ) dfg:withPredInBranch ?cur }
<= {
    ?cur ?pred ?value .
    true log:callWithCut true .
} .

{ ( ?cur (?pred ?value) ?src ) dfg:withPredInBranch ?found }
<= {
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ( ?next (?pred ?value) ?src ) dfg:withPredInBranch ?found .
} .

{
    ( ?cur ?src ?coll ) dfg:priorTransitiveClosure ?closure
} <= {
    ?l dfg:from ?from ; dfg:to ?cur ; dfg:source ?src .
    ( ?coll ( ?cur ) ) list:append ?coll2 .

    ( ?from ?src ?coll2 ) dfg:priorTransitiveClosure ?closure
} .

{
    ( ?cur ?src ?coll ) dfg:priorTransitiveClosure ?coll2
} <= {
    
    (1 { ?l dfg:from ?from ; dfg:to ?cur ; dfg:source ?src } ()) log:collectAllIn _:t .
    ( ?coll ( ?cur ) ) list:append ?coll2 .
} .