@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .

# @import utils.n3

# principles (graph-based!) - given discovered event e:
# (aside from "e", all below refers to normative model)

# 1/ causality - e _implies_ d if:
# 	reverse transitive closure of e = forward transitive closure of d
#   i.e., to arrive at e, had to have gone through d
# (special/simple case: exists normative link d -> e _and_ no other d' exists where d' <> d and d' -> e)

# special/simple case
{
    ?e dfg:inDiscovered true ; log:notEqualTo dfg:nil .
    ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .
    ?from dfg:validBranch true .

    (   # if another incoming link exists
        {
            ?l2 dfg:from ?from2 ; dfg:to ?e ; dfg:source dfg:normative .
            ?from2 log:notEqualTo ?from .   
        }
        # it must come from an invalid branch
        { ?from2 dfg:invalidBranch true }
    ) log:forAllIn _:t .

} => {
    [
        dfg:from ?from ; dfg:to ?e ; dfg:source dfg:discovered ;
        dfg:inferred [ dfg:reason "priorEvent" ; dfg:priorEvent ?e ]
    ]
} .

# complex case
{
    ?e dfg:inDiscovered true ; log:notEqualTo dfg:nil .

    # at least 2 valid incoming links
    (?l {
        ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .
        ?from dfg:validBranch true .
    } ?in) log:collectAllIn _:t .
    ?in!list:length math:notLessThan 2 .

    # "converge (0)" log:trace ?e .

    # get reverse transitive closures of all incoming links
    (?closure
        {
            ?l_n dfg:from ?from_n ; dfg:to ?e ; dfg:source dfg:normative .
            ( ?from_n dfg:normative () ) dfg:priorTransitiveClosure ?closure .
        }
    ?closures) log:collectAllIn ( ?ctx 5 ) .

    # "converge (1)" log:trace ( ?e ?closures ) .

    # if they have an element in common;
    # that element has the same forward transitive closure
    ?closures list:intersect ?shareds .
    ( ?shareds 0 ) list:memberAt ?shared .

    # "converge" log:trace ( ?e ?shared ) .

    # also, make sure these are not yet connected
    # (avoid redundant links)
    # ( ?shared ?e dfg:discovered ) dfg:reachable false .

} => {
    [ 
        a dfg:IndirectLink ;
        dfg:from ?shared ; dfg:to ?e ; dfg:source dfg:discovered ;
        dfg:inferred [ dfg:reason "convergingPriorTransitiveClosure" ]
    ]
} .


# 2/ mutually exclusive choices
# if e is a choice of a DP, this _rules out_ other choices & their unique transitive closure 
# (i.e., not incl. nodes also accessible via other nodes)

# rule out other choices given a discovered choice
{   ?e dfg:inDiscovered true .

    # event's associated DP
    ?l dfg:from ?dp ; dfg:to ?e ; dfg:source dfg:normative .
    ( ?dp dfg:normative ) dfg:decisionPoint true .

    # only reachable from this DP; any other incoming links should be invalid
    (   # for any incoming link not equal to DP's link
        { ?oil dfg:to ?e ; dfg:source dfg:normative . ?l log:notEqualTo ?oil }
        # it must come from an invalid link
        { ?oil dfg:invalidLink _:r2 }
    ) log:forAllIn _:t .

    # DP's other choices
    ?l2 dfg:from ?dp ; dfg:to ?e2 ; dfg:source dfg:normative .
    ?e2 log:notEqualTo ?e ; log:notEqualTo dfg:nil .

} => {
    ?l2 dfg:invalidLink [
        dfg:reason "otherChoiceDiscovered" ;
        dfg:otherChoice ?e
    ]
} .

# propagate invalid links & events

{
    ?l dfg:invalidLink _:r .
    ?l dfg:from ?from ; dfg:to ?e .

    # only invalidate event if all incoming links are invalid
    (   # for any incoming link
        { ?l2 dfg:to ?e ; dfg:source dfg:normative }
        # it must come from an invalid link
        { ?l2 dfg:invalidLink _:r2 }
    ) log:forAllIn _:t .

} => {
    ?e dfg:invalidEvent [
        dfg:reason "invalidatedTransitiveClosure" ;
        dfg:priorInvalid ?from
    ]
} .

# all outgoing links from invalid e are also invalid
{
    ?e dfg:invalidEvent _:r .
    ?l dfg:from ?e ; dfg:source dfg:normative .

} => {
    ?l dfg:invalidLink [
        dfg:reason "invalidatedTransitiveClosure" ;
        dfg:priorInvalid ?e
    ]
} .