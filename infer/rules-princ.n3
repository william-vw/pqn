@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .

# principles (graph-based!) - given discovered event e:
# (aside from "e", all below refers to normative model)

# 0/ find single path between discovered events
{
    ?l dfg:source dfg:discovered ; dfg:from ?from ; dfg:to ?to .
    ?to log:notEqualTo dfg:nil .

    (?path
        { ( ?from ?to dfg:normative () ) dfg:pathBetween ?path }
    ?paths) log:collectAllIn _:t .

    # "paths" log:trace ( ?from ?to ) .
    # "paths" log:trace ?paths .
    
    ?paths list:length 1 .
    # get single path
    ?path list:in ?paths .

    # get single link in path
    ( ?from_i ?to_i ) list:in ?path .
    # (not yet inferred)
    ( 1 { ?x dfg:from ?from_i ; dfg:to ?to_i ; dfg:source dfg:discovered } () ) log:collectAllIn _:t .

} => {
    # infer the link
    [
        dfg:from ?from_i ; dfg:to ?to_i ; dfg:source dfg:discovered ;
        dfg:inferred [ dfg:reason "onDiscoveredPath" ; dfg:path ( ?from ?to ) ]
    ]
} .

# 1/ if e is a choice of a DP, this _rules out other choices & their _unique_ transitive closure 
# (not incl. nodes also reachable via other nodes)

# rule out other choices given a discovered choice
{
    ?e dfg:inDiscovered true .

    # event's associated DP
    ?l dfg:from ?dp ; dfg:to ?e ; dfg:source dfg:normative .
    ( ?dp dfg:normative ) dfg:decisionPoint true .

    # DP's other choices
    ?l2 dfg:from ?dp ; dfg:to ?e2 ; dfg:source dfg:normative .
    ?e2 log:notEqualTo ?e . # ; dfg:inDiscovered false . (assume mutex choices)

    # (avoid multiple invalidations)
    ?e2 dfg:validBranch true .

} => {
    ?e2 dfg:invalidated [
        dfg:reason "otherChoiceDiscovered" ;
        dfg:otherChoice ?e
    ]
} .

# propagate invalid branch
{
    ?e dfg:invalidBranch true .

    ?l dfg:from ?e ; dfg:to ?to ; dfg:source dfg:normative .

    # (avoid multiple invalidations)
    ?to dfg:validBranch true .
    (
        # for any incoming link
        { ?lp dfg:from ?p ; dfg:to ?to ; dfg:source dfg:normative }
        # it must come from an invalid branch
        { ?p dfg:invalidBranch true }
    ) log:forAllIn _:t .

} => {
    ?to dfg:invalidated [
        dfg:reason "invalidTransitiveClosure" ;
        dfg:priorInvalid ?e
    ]
} .

# 2/ e _implies_ d if:
# 	reverse transitive closure of e = forward transitive closure of d
# 	i.e., all prior *valid* branches of e arrive at d
# (special/simple case: exists normative link d -> e _and_ no other d' exists where d' <> d and d' -> e)

# special/simple case
{
    ?e dfg:inDiscovered true .
    ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .
    ?from dfg:validBranch true .

    (   # if another incoming link exists
        {
            ?l2 dfg:from ?from2 ; dfg:to ?e ; dfg:source dfg:normative .
            ?from2 log:notEqualTo ?from .   
        }
        # it must come from an invalid branch
        { ?from2 dfg:invalidBranch true }
    ) log:forAllIn _:t .

} => {
    [
        dfg:from ?from ; dfg:to ?e ; dfg:source dfg:discovered ;
        dfg:inferred [ dfg:reason "priorEvent" ; dfg:priorEvent ?e ]
    ]
} .

# complex case
{
    ?e dfg:inDiscovered true .

    # at least 2 valid incoming links
    ?l dfg:from ?from ; dfg:to ?e ; dfg:source dfg:normative .
    ?l2 dfg:from ?from2 ; dfg:to ?e ; dfg:source dfg:normative .
    ?from2 log:notEqualTo ?from .
    ?from dfg:validBranch true .
    ?from2 dfg:validBranch true .

    # "converge" log:trace ( ?e ?from ?from2 ) .

    # get reverse transitive closures of all incoming links
    (?closure
        {
            ?l_n dfg:from ?from_n ; dfg:to ?e ; dfg:source dfg:normative .
            ( ?from_n dfg:normative () ) dfg:priorTransitiveClosure ?closure .
        }
    ?closures) log:collectAllIn ( ?ctx 5 ) .

    # "converge" log:trace ( ?e ?closures ) .

    # if they have an element in common;
    # that element has the same forward transitive closure
    ?closures list:intersect ?shareds .
    ( ?shareds 0 ) list:memberAt ?shared .

    # "converge" log:trace ( ?e ?shared ) .

    # also, make sure these are not yet connected
    # (avoid redundant links)
    ( ?shared ?e dfg:discovered ) dfg:reachable false .

} => {
    [ 
        a dfg:IndirectLink ;
        dfg:from ?shared ; dfg:to ?e ; dfg:source dfg:discovered ;
        dfg:inferred [ dfg:reason "convergingPriorTransitiveClosure" ]
    ]
} .


# helpers

{ ?m list:notIn ?lst } 
<= { (1 { ?m list:in ?lst } ()) log:collectAllIn _:t } .

{ ?lists list:intersect ?intersect }
<= {
    ( ?lists 0 ) list:memberAt ?list_0 .
    (?element
        {
            ?element list:in ?list_0.
            (
                { ?list_i list:in ?lists }
                { ?element list:in ?list_i }
            ) log:forAllIn _:t . 
        }
    ?intersect ) log:collectAllIn _:t .
} .

{ ?e dfg:link ?l }
<= { ?l dfg:from ?e } .

{ ?e dfg:link ?l }
<= { ?l dfg:to ?e } .

# { ?e a dfg:Activity } <= { ?l dfg:from ?e } .
# { ?e a dfg:Activity } <= { ?l dfg:to ?e } .

{ ( ?pt ?src ) dfg:decisionPoint true } 
<= {
    ?l1 dfg:from ?pt ; dfg:to ?to1 ; dfg:source ?src .
    ?l2 dfg:from ?pt ; dfg:to ?to2 ; dfg:source ?src .
    ?l1 log:notEqualTo ?l2 .
    ?to1 log:notEqualTo ?to2 .
} .

{ ( ?pt ?src ) dfg:decisionPoint false } 
<= {
    ( 1 { ( ?pt ?src ) dfg:decisionPoint true } () ) log:collectAllIn _:t .
} .

{ ?e dfg:inNormative true }
<= { ?e dfg:foundIn dfg:normative } .

{ ?e dfg:inDiscovered true }
<= { ?e dfg:foundIn dfg:discovered } .

{ ?e dfg:foundIn ?src }
<= { ?e dfg:link ?l . ?l dfg:source ?src } .

{ ?e dfg:inNormative false }
<= { ?e dfg:notFoundIn dfg:normative }.

{ ?e dfg:inDiscovered false }
<= { ?e dfg:notFoundIn dfg:discovered }.

{ ?e dfg:notFoundIn ?src }
<= { 
    (1 { ?e dfg:link ?l . ?l dfg:source ?src } ()) log:collectAllIn _:t .
    # messes up log:trace's
    # _:t log:notIncludes { ?e dfg:link ?l . ?l dfg:source ?src } 
} .

{ ?e dfg:invalidBranch true } 
<= { ?e dfg:invalidated _:e } .

{ ?e dfg:validBranch true } 
<= { ( 1 { ?e dfg:invalidated _:e } () ) log:collectAllIn _:t } .

{
    ( ?cur ?src ?coll ) dfg:priorTransitiveClosure ?closure
} <= {
    ?l dfg:from ?from ; dfg:to ?cur ; dfg:source ?src .
    ?cur list:notIn ?coll .
    ( ?coll ( ?cur ) ) list:append ?coll2 .

    ( ?from ?src ?coll2 ) dfg:priorTransitiveClosure ?closure
} .

{
    ( ?cur ?src ?coll ) dfg:priorTransitiveClosure ?coll2
} <= {
    
    (1 { ?l dfg:from ?from ; dfg:to ?cur ; dfg:source ?src } ()) log:collectAllIn _:t .
    ( ?coll ( ?cur ) ) list:append ?coll2 .
} .


{ ( ?from ?from ?src ?coll ) dfg:pathBetween ?coll } 
<= { true log:callWithCut true } .

{ ( ?from ?to ?src ?coll ) dfg:pathBetween ?path } 
<= {
    ?l dfg:from ?prior ; dfg:to ?to ; dfg:source ?src .
    # "pathBetween" log:trace ( ?prior ?to ?coll ) .

    ( ?prior ?to ) list:notIn ?coll .
    ( ?coll ( ( ?prior ?to ) ) ) list:append ?coll2 .

    ( ?from ?prior ?src ?coll2 ) dfg:pathBetween ?path
} .

{ ( ?cur ?cur ?src ?coll ) dfg:reachable true }
<= { true log:callWithCut true } .

{ ( ?cur ?to ?src ) dfg:reachable true }
<= {
    ?l dfg:from ?cur ; dfg:to ?next ; dfg:source ?src .
    ( ?next ?to ?src ) dfg:reachable true .
} .

{ ( ?cur ?to ?src ) dfg:reachable false }
<= { 
    ( 1 { ( ?cur ?to ?src ) dfg:reachable true } () ) log:collectAllIn _:t .
} .