@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix dfg: <http://rdf.org/dfg#> .
@prefix : <http://example.org/> .


# > run tests
# princ:
# eye utils.n3 rules-princ.n3 --turtle ./data/tests/princ1.5.n3 --pass-only-new > ./data/out/princ1.5.n3
# eye utils.n3 rules-princ.n3 --turtle ./data/tc/1/disc.n3 ./data/tc/1/norm.n3 --pass-only-new > ./data/out/tc/1.n3
# eye utils.n3 rules-consist.n3 --turtle ./data/tests/princ1.5.n3 ./data/out/princ1.5.n3 --pass-only-new

# { ( :z :c dfg:discovered ) dfg:reachable false }
# => { ( :z :c dfg:discovered ) dfg:reachable false } .

# test data:
# eye test.n3 / rules.n3 --turtle ./data/data1.n3 --query query.n3 --nope
# pilot medical:
# eye rules.n3 --turtle ./data/tc/2/norm.n3 ./data/tc/2/disc.n3 --query query.n3 --nope
# implic:
# eye implic.n3 --turtle ./data/tests/determ/determB.n3 ./data/tests/determ/determB-pos1.n3 --pass-only-new --nope > ./data/out/implic-determB-pos1.n3


# > invalidation but mutex

# e.g.,
# <http://canada.org/tc#fileretrieval> dfg:invalidated _:sk_17.
# _:sk_17 dfg:reason "otherChoiceDiscovered".
# _:sk_17 dfg:otherChoice <http://canada.org/tc#completed-assessmentcomplete>.

# eye utils.n3 data/tc/all/norm.n3 data/out/tc_all_norm_closure.n3 data/tc/all/diff-0.n3 data/out/tc_all_norm_diff-0.n3 --query query.n3 --nope

{   ?inv dfg:invalidated [
        dfg:reason "otherChoiceDiscovered" ;
        dfg:otherChoice ?chosen
    ] .
    # ( ?inv ?chosen dfg:normative ) dfg:ancestor true .
    ( ?ancestors 
        { ?chosen dfg:ancestors ?ancestors . ?inv list:in ?ancestors }
    ?all ) log:collectAllIn _:t .

    ( ?all 0 ) list:memberAt ?ancestors0

} => {  ?inv :invalidInvalidation ( ?inv :ancestorOf ?chosen ) . ?chosen :ancestors ?ancestors0 } .


# > miscellaneous tests

# { ( (:x :a) (:x :b :c :e) (:x :b :d) (:k :c :e) (:k :l) ) list:flatten ?flat .
#   ?flat list:unique ?set .
# } => { <> :out ?set } .

# {
#     ( <http://canada.org/tc#inprogress-letter-defer> <http://canada.org/tc#end> dfg:normative )
#         dfg:ancestor false

# } => { <> :out "not ancestor!" } .

# { 
#     ?pt dfg:inNormative true .
#     ( ?pt dfg:normative ) dfg:decisionPoint true .

# } => { ?pt :found true } .

# { 
#     ( ?pt dfg:normative ) dfg:decisionPoint true .
#     ?pt dfg:inDiscovered false .

# } => { ?pt :found true } .

# { ( :b dfg:decisionPoint dfg:normative () ) dfg:collectAncestors ?anc } 
# => { ( :b dfg:decisionPoint dfg:normative () ) dfg:collectAncestors ?anc } .

# { ( ( :b ) ( :b ) :e dfg:normative ) dfg:forAllPriorBranches true }
# => { ( ( :b ) ( :b ) :e dfg:normative ) dfg:forAllPriorBranches true } .

# { ( :y ( :x ) dfg:normative ) dfg:inSomeBranch true }
# => { ( :y ( :x ) dfg:normative ) dfg:inSomeBranch true } .

# - determinant

# { ( :e :b ) dfg:determinant true }
# => { ( :e :b ) dfg:determinant true } .

# { ( :c :b ) dfg:determinant true }
# => { ( :c :b ) dfg:determinant true } .

# -- test A
# eye rules.n3 --turtle ./data/tests/determ/determA.n3 ./data/tests/determ/determA-pos1.n3 --query query.n3 --nope

# -- test B
# eye rules.n3 --turtle ./data/tests/determ/determB.n3 ./data/tests/determ/determB-pos1.n3 --query query.n3 --nope
# eye rules.n3 --turtle ./data/tests/determ/determB.n3 ./data/tests/determ/determB-neg1.n3 --query query.n3 --nope
# eye rules.n3 --turtle ./data/tests/determ/determB.n3 ./data/tests/determ/determB-neg2.n3 --query query.n3 --nope

# - consistent link

# { ( :x :c3 ) dfg:consistentLink true }
# => { ( :x :c3 ) dfg:consistentLink true } .

# eye rules.n3 --turtle ./data/tests/consistLnk/consistLnkA.n3 ./data/tests/consistLnk/consistLnkA-pos1.n3 --query query.n3 --nope

# - list intersect

# {
#     ( ( :o :f :d :r ) ( :p :g :d :s ) ) list:intersect ?intersect
# } => {
#     <> :out ?intersect
# } .



# > heuristic tests

# TODO determB-neg1 - are inferences wrong? 
# (:c is a valid option for both :k and :b)

# (consistLnk, determinant determ tests)
# { ( ?pt ?d ) dfg:inferredDecisionFromFollowingEvent ?e } 
# # => { ( ?pt ?d ) dfg:inferredDecisionFromFollowingEvent ?e } .
# => {
#     [
#         dfg:from ?pt ;
#         dfg:to ?d ;
#         dfg:source dfg:discovered ;
#         dfg:inferred [ 
#             dfg:heuristic "inferredDecisionFromFollowingEvent" ;
#             dfg:followingEvent ?e
#         ]
#     ]
# } .

# (heur1.n3)
# { ( ?from ?to ) dfg:inferredEventFromKnownEvent ?known_e }
# => {
#     [
#         dfg:from ?from ;
#         dfg:to ?to ;
#         dfg:source dfg:discovered ;
#         dfg:inferred "inferredEventFromKnownEvent"
#     ]
# } .

# { ?pt dfg:inferredDecisionPointFromDecision ?d } 
# # => { ?pt dfg:inferredDecisionPointFromDecision ?d } .
# => {
#     [
#         dfg:from ?pt ;
#         dfg:to ?d ;
#         dfg:source dfg:discovered ;
#         dfg:inferred "inferredDecisionPointFromDecision"
#     ]
# } .